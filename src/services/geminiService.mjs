import { GoogleGenerativeAI, SchemaType } from "@google/generative-ai";
import asyncHandler from "../middleware/asyncHandler.mjs";

const apiKey = process.env.GEMINI_API_KEY;
const genAI = new GoogleGenerativeAI(apiKey);

// Initialize the Gemini model
const model = genAI.getGenerativeModel({
    model: "gemini-1.5-flash",
});

// Define the response schema
const responseSchema = {
    type: SchemaType.OBJECT,
    properties: {
        amount: {
            type: SchemaType.NUMBER,
        },
        currency: {
            type: SchemaType.STRING,
        },
        category: {
            type: SchemaType.STRING,
        },
        description: {
            type: SchemaType.STRING,
        },
    },
    required: ["amount", "currency", "category", "description"],
};

// Define the generation configuration
const generationConfig = {
    // Controls the randomness of the output. Lower values produce more predictable and conservative output, while higher values produce more diverse and creative output.
    temperature: 1,

    // The proportion of the most probable tokens to consider for prediction. A value of 0.95 means that the top 95% of the most probable tokens will be considered.
    topP: 0.95,

    // The maximum number of tokens to consider for prediction. A value of 64 means that the model will consider up to 64 tokens.
    topK: 64,

    // The maximum number of tokens to generate for the output. A value of 8192 means that the model can generate up to 8192 tokens (characters).
    maxOutputTokens: 8192,

    // The MIME type of the output. This is set to "application/json" to indicate that the output is a JSON object.
    responseMimeType: "application/json",

    // The schema of the output. This is set to the responseSchema object, which defines the structure of the output.
    responseSchema: responseSchema,
};

/**
 * Builds a prompt for the Gemini AI model to extract an expense entry from a
 * given user message. The prompt is structured as a JSON object with the
 * following properties:
 *
 * - `amount`: The numeric value of the expense.
 * - `category`: The category of the expense, chosen from a list of predefined
 *     categories.
 * - `currency`: The currency of the expense, assumed to be INR if not
 *     explicitly mentioned.
 * - `description`: A short description of the expense.
 *
 * The prompt is generated by wrapping the user message with a set of
 * instructions and examples for the Gemini model to follow.
 * @param {string} message The user message to be processed.
 * @returns {Object} The Gemini prompt object.
 */
const buildGeminiPrompt = (message) => {
    return {
        prompt: `
            Interpret the following user input as an expense entry. The user might be using Hinglish (a mix of Hindi and English) or Banglish (a mix of Bengali and English). Here's the task:

            1. Identify the amount (e.g., "200", "₹500", "150 dollars").
            2. Identify the currency (assume INR if not explicitly mentioned).
            3. Categorize the expense into one of the predefined categories: 
                [Housing, Utilities, Food & Beverages, Transportation, Shopping, Health, Entertainment, Education, Travel, Miscellaneous].
            4. If multiple categories fit, prioritize the most specific one.
            5. Extract a short description of the expense.

            Consider nuances like:
            - Hinglish or Banglish phrases such as "500 kharcha kiya khana pe" or "200 diye cinema jete."
            - Variants for "rupees" (e.g., "₹", "rs", "rupaiya", "টাকা").
            - Common terms for daily activities like eating out, shopping, commuting, or paying bills.

            Respond with a structured JSON:
            {
                "amount": <numeric_value>,
                "category": <category_name>,
                "description": <short_description>
            }

            Example input: "500 ka kharcha kiya khane pe"
            Example response:
            {
                "amount": 500,
                "currency": "INR",
                "category": "Food & Dining",
                "description": "Expense on eating out"
            }

            Now process this message:
            "${message}"
        `,
    };
};

/// Call the Gemini API to interpret the user message and generate a response
/// based on the defined prompt and generation configuration.
export const callGeminiAPI = asyncHandler(async (message) => {
    console.log("Message: ", message);
    const { prompt } = buildGeminiPrompt(message);
    console.log("Prompt: ", prompt);
    const result = await model.generateContent(prompt, generationConfig);

    console.dir(result, { depth: null });
    return result.response.text();
});

// Call the Gemini API and parse the response to extract the relevant data
/// (amount, category, description). The response is expected to be in JSON format.
export const getParsedGeminiResponse = asyncHandler(async (message) => {
    const interpretMessage = await callGeminiAPI(message);
    return JSON.parse(interpretMessage.replace(/```json|```/g, "").trim());
});
